"Individual Models"),
fill = c("red", "black"))
View(WIS_last2weeks)
df2 <- WIS_last2weeks
library(tidyverse)
library(epiDisplay)
library(MMWRweek)
library(dplyr)
library(forcats)
'%notin%' <- Negate('%in%')
last.tuesday = as.Date("2022-11-01")
window.width = c(2, 4, 8)
eval.weeks = 8
weeks.to.eval =
seq((last.tuesday+4)- 7*(eval.weeks-1) - 7*(max(window.width)-1),
last.tuesday+4,
by=7) %>%
as.character()
CDCid="rpe5"#"oko8"
userid <- CDCid
#ncov19hub <- paste0("C:/Users/",CDCid,"/OneDrive - CDC/Projects/nCov-2019/Forecast visualization/")
#hubpath = paste0("C:/Users/",CDCid,"/OneDrive - CDC/Projects/covid19-forecast-hub")
# hubpath <-"C:/Users/rpe5/Desktop/GitHub/covid19-forecast-hub"
# ncov19hub <-"C:/Users/rpe5/Desktop/GitHub/nCov-2019/Forecast visualization/"
dashpath <- paste0("C:/Users/",userid,"/Desktop/GitHub/Flu-Visualizations/Dashboard R Code")
hubpath <-paste0("C:/Users/",CDCid,"/Desktop/GitHub/Flusight-forecast-data")
ncov19hub <- paste0("C:/Users/",userid,"/Desktop/GitHub/Flu-Visualizations/Dashboard R Code/Weekly Data/")
get_next_saturday <- function(date) {
require(lubridate)
date <- as.Date(date)
## calculate days until saturday (day 7)
diff <- 7 - wday(date)
## add to given date
new_date <- diff + date
return(new_date)
}
get_next_tuesday <- function(date) {
require(lubridate)
date <- as.Date(date)
## calculate days until saturday (day 7)
diff = ifelse(wday(date) <= (3), 3-wday(date), 3+7-wday(date))
## add to given date
new_date <- diff + date
return(new_date)
}
select = dplyr::select
filter = dplyr::filter
##########################################################################################################
#########################################################################################################
datapath <- paste0(hubpath,"/data-forecasts")
filenames = list.files(path=datapath, pattern=".csv",
full.names = TRUE, recursive = TRUE)
unique_model_names <- unique(str_split(filenames, "/", simplify = TRUE)[, 8:9])
unique_model_names = cbind(unique_model_names, substr(unique_model_names[,2],1,10) )
unique_model_names = data.frame(model = as.character(unique_model_names[,1]),
filename = as.character(unique_model_names[,2]),
date.submitted = unique_model_names[,3],
next.tuesday = get_next_tuesday(as.Date(unique_model_names[,3]))) %>%
group_by(model, next.tuesday) %>%
summarise(filename = as.character(filename[which.max(as.Date(date.submitted))])) %>%
ungroup() %>%
mutate(model = as.character(model),
next.tuesday = as.character(next.tuesday)) %>%
filter(next.tuesday %in%
as.character(
last.tuesday - 7*(0:((eval.weeks-1)+max(window.width)+(4-1)-1))
)
) %>%
filter(next.tuesday == as.character(last.tuesday))
#unique_model_names <- unique_model_names[-which(unique_model_names$model == "COVIDhub-ensemble"),]
filenames =
paste0(hubpath,"/data-forecasts/",
unique_model_names$model, "/",
unique_model_names$filename)
dat_list <- lapply(filenames,
FUN = function(x){
read_csv(x, col_types = cols(.default = "c")) %>%
filter(grepl("hosp", target),
target %in% c(#paste(1:4,"wk ahead cum death"),
paste(1:4,"wk ahead inc flu hosp"))#,
#target_end_date == as.character(last.tuesday+4)
)
}
)
models = unique_model_names$model
unique_models = unique(models)
## load in all files sequentially
all_dat_new <- tibble()
for (i in c(1:length(dat_list))) {
all_dat_new <- bind_rows(all_dat_new,
dat_list[[i]] %>%
select(location, target, target_end_date, forecast_date,
type, quantile, value) %>%
mutate(
location = as.character(location),
location =
as.character(ifelse(location %in% as.character(1:9),
paste0("0",location),location)),
model = models[i],
value = as.numeric(value),
quantile = as.numeric(quantile)  ,
quantile=ifelse(quantile=="NaN", NA, quantile)
)
)
}
#all_dat_new <-all_dat_new %>%
#  filter(!(model %in% models_to_exclude))
# load old data
week.to.drop = as.character(last.tuesday-7*((eval.weeks-1)+max(window.width)+(4-1)-1))
load(paste0(ncov19hub,"WIS eval datasets/Hosp_WIS_2022_EW",MMWRweek(last.tuesday-7)$MMWRweek,".Rdata"))
all_dat =
rbind(all_dat_new,
all_dat,
filter(all_dat, target_end_date %in% weeks.to.eval)
)
all_dat <- unique(all_dat)
#all_dat <- all_dat_new
## save data
save(all_dat, file = paste0(ncov19hub,"WIS eval datasets/Hosp_WIS_2022_EW",MMWRweek(last.tuesday)$MMWRweek,".Rdata"))
## get truth data
obs_data <- read_csv(paste0(hubpath,"/data-truth/truth-Incident Hospitalizations.csv")) %>%
mutate(wk_end_date = as.Date(date, "%m/%d/%y"),
location_name = ifelse(location == 'US', 'National', location_name)) %>%
select(-date) %>%
filter(wk_end_date %in% as.Date(unique(all_dat$target_end_date) ))
#obs_data = obs_data[which(nchar(obs_data$location)<=2),]
obs_data <- obs_data %>%
rename(value_inc = value,
target_end_date = wk_end_date) %>%
filter(target_end_date < Sys.Date())
location.names = obs_data %>% select(location, location_name) %>% unique()
all_dat = left_join(all_dat,location.names, by = c("location"))
suppressMessages(invisible(source(paste0(ncov19hub,"Model names and colors.R"))))
unique(all_dat$model)
#inc.ensemble.inclusion = data.frame()
#for(i in c(as.character(last.tuesday-7*(0:((eval.weeks-1)+max(window.width)+(4-1)-1))-1)))
#  {
#  f <- ifelse(as.Date(i) > as.Date("2021-09-01"),"/4_week_ensemble-metadata/","/ensemble-metadata/")
#  elig = read.csv(paste0(hubpath,f,i,"-inc_death-model-eligibility.csv")) %>%
#  mutate(location = as.character(location),
#          location =
#           ifelse(as.character(location) %in% as.character(1:9),
#            paste0("0",location),location)) %>%
#left_join(location.names) %>%
#     mutate(submission_deadline = as.Date(i)+1) %>%
#   select(submission_deadline, model, location_name, overall_eligibility)
#  inc.ensemble.inclusion =
#    rbind(inc.ensemble.inclusion, elig)
#  }
source(paste0(ncov19hub,"WIS_calculation_function.R"))
library(tidyverse)
library(DT)
library(MMWRweek)
library(plotly)
library(dplyr)
################### WIS calculation
# Set up alpha's and k
# intervals = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 98)
#
# alpha_05 <-0.05
# alpha_20 <-0.20
# alpha_50 <-0.50
# alpha_0 <-1.0
#
# k <- length(intervals)-1 #number of intervals
#
# quantile.vars =
#   sort(unique(c(50 - intervals/2, 50 + intervals/2)))/100
#
# quantile.vars = quantile.vars/100
# First: Indicator function
# Second: IS at each quantile, at each time point
# Third: Sum all IS at each time point
# Fourth: Create WIS at each time point
## Reformat data and create scores
#all_dat <-all_dat[!duplicated(all_dat),]
all_dat <-drop_na(all_dat) #additional confirmation that all quants are present
dat_for_scores <- all_dat %>%
mutate(target_end_date = as.Date(target_end_date),
forecast_date = as.Date(forecast_date),
value = case_when(quantile==0.5 ~ round(value),
quantile<0.5 ~ floor(value),
quantile>0.5 ~ ceiling(value),
type=='point' ~ round(value)),
submission_deadline =
get_next_tuesday(as.Date(forecast_date))) %>%
#left_join(inc.ensemble.inclusion,
#         by = c("submission_deadline", "model", "location_name")) %>%
filter(! (type=="quantile" & is.na(quantile)),
! type == "point",
#(overall_eligibility == "eligible" | model %in% c("COVIDhub-4_week_ensemble","COVIDhub-baseline", "COVIDhub-trained_ensemble"))
) %>%
#filter(as.Date(target_end_date) <= get_next_tuesday(as.Date(forecast_date))) %>%
left_join( obs_data %>% rename(report = value_inc),
by=c("target_end_date", "location_name", "location"))%>%
mutate(
report = ifelse(grepl("inc flu hosp",target),
report)) %>%
rename(date = target_end_date) %>%
filter(!is.na(report))
dat_for_scores <- distinct(dat_for_scores)
WIS_all  =
left_join(dat_for_scores %>%
filter(quantile %in% c(0.025, 0.25, 0.5, 0.75, 0.975)) %>%
pivot_wider(names_from = c(type, quantile), values_from=value),
WIS_calculation(),
by = c("model", "date", "location_name","forecast_date")) %>%
mutate(WIS_rel = ifelse(report==0, WIS/1, WIS/report),
abs.error = abs(quantile_0.5 - report),
perc.point.error = 100*abs.error/report,
coverage.50 = ifelse(report >= quantile_0.25 & report <= quantile_0.75,T,F),
coverage.95 = ifelse(report >= quantile_0.025 & report <= quantile_0.975,T,F)
) %>%
rename(target_end_date = date)
# pull out data on forecasts of the last 1, 4, and 8 observed weeks
WIS_all = filter(WIS_all, location_name != "National")
WIS_last2weeks =
filter(WIS_all, as.Date(target_end_date) %in% c(last.tuesday + 4 - 7*(0:1)))
WIS_last4weeks =
filter(WIS_all, as.Date(target_end_date) %in% c(last.tuesday + 4- 7*(0:3)))
WIS_last8weeks =
filter(WIS_all, as.Date(target_end_date) %in% c(last.tuesday + 4- 7*(0:7)))
locations_fully_forecasted = function(df, target.type = c("inc flu hosp")){
df = filter(df, grepl(target.type,target))
model = unique(df$model)
data.frame(model,
locations.fully.forecasted =
map_dbl(.x=model,
.f=function(.x){
locations.fully.submitted =
df %>%
filter(model == .x,
target %in% paste(1:4,
"wk ahead",
target.type)) %>%
group_by(location_name) %>%
summarise(subs = n()) %>%
ungroup() %>%
filter(subs >=
2*(length(unique(df$target_end_date)))) %>%
nrow()
return(locations.fully.submitted)
})
)
}
make_WIS_ranking = function(df, target.type = c("inc flu hosp")){
df = filter(df, grepl(target.type,target))
models = unique(df$model)
M = length(models)
mean.WIS =
map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% dplyr::select(WIS) %>% unlist() %>% mean()
})
MAE =
map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% dplyr::select(abs.error) %>% unlist() %>% mean(na.rm=T)
})
# Mean.Perc.Error =
#    map_dbl(.x = models,
#   .f = function(.x){
#    filter(df, model ==.x) %>% select(perc.point.error) %>% unlist() %>% mean(na.rm=T)
#           })
Percent.Cov.50 =
round(100*map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% select(coverage.50) %>% unlist() %>% mean(na.rm=T)
}))
Percent.Cov.95 =
round(100*map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% select(coverage.95) %>%
unlist() %>% mean(na.rm=T)}))
phi.ij = matrix(nrow=M,ncol=M, dimnames = list(models,models))
for(i in 1:M)
{
for(j in 1:M)
{
mean.WIS.pairwise =
inner_join(filter(df,model==models[i]),
filter(df,model==models[j]),
by=c("target","location_name","target_end_date")) %>%
select(WIS.x,WIS.y) %>%
colMeans()
phi.ij[i,j] = (mean.WIS.pairwise[1])/mean.WIS.pairwise[2]
# phi.ij[i,j] = mean(mean.WIS.pairwise$WIS.x/mean.WIS.pairwise$WIS.y,na.rm=T)
}
}
phi.i =
map_dbl(.x = 1:nrow(phi.ij),
.f =function(.x){
entries = which(!is.na(phi.ij[.x,]))
prod(phi.ij[.x, entries])^(1/length(entries))
#mean(phi.ij[.x, entries])
})
data.frame(models, mean.WIS, rel.WIS.skill=phi.i,
MAE, Percent.Cov.50,
Percent.Cov.95,
frac.forecasts.submitted =
map_dbl(.x=models,
.f=function(.x){
nrow(unique(select(filter(df,model==.x), target, target_end_date, location_name)))/
(4*length(unique(df$target_end_date))*length(unique(WIS_all$location_name)))
}),
frac.locations.submitted =
map_dbl(.x=models,
.f=function(.x){
length(unique(filter(df, model == .x)$location_name))/
length(unique(df$location_name))
}),
frac.locations.fully.forecasted =
map_dbl(.x=models,
.f=function(.x){
locations.fully.submitted =
df %>%
filter(model == .x,
target %in% paste(1:4,"wk ahead",target.type)) %>%
group_by(location_name) %>%
summarise(subs = n()) %>%
ungroup() %>%
# filter(subs >= 2*(length(unique(df$target_end_date)))) %>%
nrow()
return(locations.fully.submitted/length(unique(df$location_name)))
})
) %>%
arrange(rel.WIS.skill) %>%
mutate(rank = order(rel.WIS.skill),
frac.forecasts.submitted =
frac.forecasts.submitted,
frac.locations.submitted =
frac.locations.submitted,
frac.locations.fully.forecasted = #frac.locations.submitted,
frac.locations.fully.forecasted,
frac.submitted.locations.fully.forecasted =
frac.locations.fully.forecasted/frac.locations.submitted)
}
phi.ij = function(df, target.type = c("inc flu hosp")){
df = filter(df, grepl(target.type,target))
models = unique(df$model)
M = length(models)
phi.ij = matrix(nrow=M,ncol=M, dimnames = list(models,models))
for(i in 1:M)
{
for(j in 1:M)
{
mean.WIS.pairwise =
inner_join(filter(df,model==models[i]),
filter(df,model==models[j]),
by=c("target","location_name","target_end_date")) %>%
select(WIS.x,WIS.y) %>%
colMeans()
phi.ij[i,j] = (mean.WIS.pairwise[1])/mean.WIS.pairwise[2]
# phi.ij[i,j] = mean(mean.WIS.pairwise$WIS.x/mean.WIS.pairwise$WIS.y,na.rm=T)
}
}
phi.ij
}
make_WIS_ranking_baseline = function(df, target.type = c("inc flu hosp")){
df = filter(df, grepl(target.type,target))
models = unique(df$model)
M = length(models)
mean.WIS =
map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% dplyr::select(WIS) %>% unlist() %>% mean()
})
MAE =
map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% dplyr::select(abs.error) %>% unlist() %>% mean(na.rm=T)
})
# Mean.Perc.Error =
#    map_dbl(.x = models,
#   .f = function(.x){
#    filter(df, model ==.x) %>% select(perc.point.error) %>% unlist() %>% mean(na.rm=T)
#           })
Percent.Cov.50 =
round(100*map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% select(coverage.50) %>% unlist() %>% mean(na.rm=T)
}))
Percent.Cov.95 =
round(100*map_dbl(.x = models,
.f = function(.x){
filter(df, model ==.x) %>% select(coverage.95) %>%
unlist() %>% mean(na.rm=T)}))
phi.ij = matrix(nrow=M,ncol=M, dimnames = list(models,models))
for(i in 1:M)
{
for(j in 1:M)
{
mean.WIS.pairwise =
inner_join(filter(df,model==models[i]),
filter(df,model=="Flusight-baseline"),
by=c("target","location_name","target_end_date")) %>%
select(WIS.x,WIS.y) %>%
colMeans()
phi.ij[i,j] = (mean.WIS.pairwise[1])/mean.WIS.pairwise[2]
# phi.ij[i,j] = mean(mean.WIS.pairwise$WIS.x/mean.WIS.pairwise$WIS.y,na.rm=T)
}
}
phi.i =
map_dbl(.x = 1:nrow(phi.ij),
.f =function(.x){
entries = which(!is.na(phi.ij[.x,]))
prod(phi.ij[.x, entries])^(1/length(entries))
#mean(phi.ij[.x, entries])
})
data.frame(models, mean.WIS, rel.WIS.skill=phi.i,
MAE, Percent.Cov.50,
Percent.Cov.95,
frac.forecasts.submitted =
map_dbl(.x=models,
.f=function(.x){
(nrow(unique(select(filter(df,model==.x), target, target_end_date, forecast_date, location_name))) + (ifelse("2022-10-24" %in% as.character(df$target_end_date) & "2022-10-31" %notin% as.character(df$target_end_date) & "2022-11-07" %notin% as.character(df$target_end_date), 3, ifelse("2022-10-24" %in% as.character(df$target_end_date) & "2022-10-31" %in% as.character(df$target_end_date) & "2022-11-07" %notin% as.character(df$target_end_date), 5, ifelse("2022-10-24" %in% as.character(df$target_end_date) & "2022-10-31" %in% as.character(df$target_end_date) & "2022-11-07" %in% as.character(df$target_end_date), 6, ifelse("2022-10-24" %notin% as.character(df$target_end_date) & "2022-10-31" %in% as.character(df$target_end_date) & "2022-11-07" %in% as.character(df$target_end_date), 3, ifelse("2022-10-24" %notin% as.character(df$target_end_date) & "2022-10-31" %notin% as.character(df$target_end_date) & "2022-11-07" %in% as.character(df$target_end_date), 1, 0)))))*(length(unique(df$location_name)))))/(((4*length(unique(df$target_end_date))))*(length(unique(df$location_name))))
}),
frac.locations.submitted =
map_dbl(.x=models,
.f=function(.x){
length(unique(filter(df, model == .x)$location_name))/
(length(unique(df$location_name)))
}),
frac.locations.fully.forecasted =
map_dbl(.x=models,
.f=function(.x){
locations.fully.submitted =
df %>%
filter(model == .x,
target %in% paste(1:4,"wk ahead",target.type)) %>%
group_by(location_name) %>%
summarise(subs = n()) %>%
ungroup() %>%
filter(subs >= 2*(length(unique(df$target_end_date)))) %>%
nrow()
return(locations.fully.submitted/length(unique(df$location_name)))
})
) %>%
arrange(rel.WIS.skill) %>%
mutate(rank = order(rel.WIS.skill),
frac.forecasts.submitted =
frac.forecasts.submitted,
frac.locations.submitted =
frac.locations.submitted,
frac.locations.fully.forecasted = #frac.locations.submitted,
frac.locations.fully.forecasted,
frac.submitted.locations.fully.forecasted =
frac.locations.fully.forecasted/frac.locations.submitted)
}
phi.ij = function(df, target.type = c("inc flu hosp")){
df = filter(df, grepl(target.type,target))
models = unique(df$model)
M = length(models)
phi.ij = matrix(nrow=M,ncol=M, dimnames = list(models,models))
for(i in 1:M)
{
for(j in 1:M)
{
mean.WIS.pairwise =
inner_join(filter(df,model==models[i]),
filter(df,model=="Flusight-baseline"),
by=c("target","location_name","target_end_date")) %>%
select(WIS.x,WIS.y) %>%
colMeans()
phi.ij[i,j] = (mean.WIS.pairwise[1])/mean.WIS.pairwise[2]
# phi.ij[i,j] = mean(mean.WIS.pairwise$WIS.x/mean.WIS.pairwise$WIS.y,na.rm=T)
}
}
phi.ij
}
options(dplyr.summarise.inform = FALSE)
WIS_last2weeks =
left_join(WIS_last2weeks,
locations_fully_forecasted(WIS_last2weeks),
by = "model") %>%
#  filter(locations.fully.forecasted >= 40) %>%
select(-locations.fully.forecasted)
inc.rankings_last.2.weeks =
make_WIS_ranking_baseline(WIS_last2weeks) %>%
select(-rank) %>%
#  filter(frac.locations.fully.forecasted >= 40/length(unique(WIS_last2weeks$location_name))) %>%
mutate(models = model_display_names[as.character(models)],
mean.WIS = round(mean.WIS,2),
rel.WIS.skill = round(rel.WIS.skill,2),
MAE = round(MAE,2),
frac.forecasts.submitted = round(100*frac.forecasts.submitted),
frac.locations.submitted = round(100*frac.locations.submitted),
frac.locations.fully.forecasted =
round(100*frac.locations.fully.forecasted),
frac.submitted.locations.fully.forecasted =
round(100*frac.submitted.locations.fully.forecasted)) %>%
rename(Model = models,
`Absolute WIS` = mean.WIS,
`Relative WIS`= rel.WIS.skill,
`50% Coverage (%)` = Percent.Cov.50,
`95% Coverage (%)` = Percent.Cov.95,
`% of Forecasts Submitted`  = frac.forecasts.submitted,
`% of Locations Forecasted` = frac.locations.submitted,
`% of Locations Fully Forecasted` = frac.locations.fully.forecasted,
`% of Submitted Locations with All Forecasts` = frac.submitted.locations.fully.forecasted)
inc.rankings_last.2.weeks %>%
select(Model, `Absolute WIS`, `Relative WIS`,
MAE, `50% Coverage (%)`,
`95% Coverage (%)`,
`% of Forecasts Submitted`) %>%
datatable()
df1 <- WIS_last2weeks
View(df2)
df1 <- df1 %>% filter(model == "Flusight-baseline")
df2 <- df2 %>% filter(model == "Flusight-baseline")
View(df2)
View(df1)
